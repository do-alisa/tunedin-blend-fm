import { useEffect, useRef, useState } from "react";
import "./App.css";

function App() {
  const didSpotifyExchangeRef = useRef(false);

  const [user1, setUser1] = useState("");
  const [user2, setUser2] = useState("");
  const [blendUser1, setBlendUser1] = useState("");
  const [blendUser2, setBlendUser2] = useState("");

  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [blend, setBlend] = useState([]);
  const [debug, setDebug] = useState(null);

  const [profile1, setProfile1] = useState(null);
  const [profile2, setProfile2] = useState(null);


  const [spotifyConnected, setSpotifyConnected] = useState(false);


  const SPOTIFY_CLIENT_ID = import.meta.env.VITE_SPOTIFY_CLIENT_ID;
  const REDIRECT_URI = "http://127.0.0.1:5173/callback";
  const SPOTIFY_SCOPES = "playlist-modify-private";

  const BLEND_STORAGE_KEY = "tunedfm-blend";

  useEffect(() => {
    fetch("http://127.0.0.1:3001/api/spotify/status")
      .then(res => res.json())
      .then(data => setSpotifyConnected(!!data.connected))
      .catch(() => setSpotifyConnected(false));
  }, []);

  useEffect(() => {
    try {
      const saved = localStorage.getItem(BLEND_STORAGE_KEY);
      if (saved) {
        const { blend: savedBlend, user1: savedUser1, user2: savedUser2 } = JSON.parse(saved);
        if (Array.isArray(savedBlend) && savedBlend.length > 0) {
          setBlend(savedBlend);
          if (savedUser1 != null) {
            setUser1(savedUser1);
            setBlendUser1(savedUser1);
          }
          if (savedUser2 != null) {
            setUser2(savedUser2);
            setBlendUser2(savedUser2);
          }
        }
      }
    } catch (_) {}
  }, []);


  function connectSpotify() {
    window.location.href = "http://127.0.0.1:3001/api/auth/spotify/start";
  }


  async function exportToSpotify() {
    try {
      setError("");

      const res = await fetch("http://127.0.0.1:3001/api/spotify/export", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name: `TunedIn Blend: ${blendUser1 || user1} + ${blendUser2 || user2}`,
          description: "Generated by TunedIn Blend",
          tracks: blend.map(t => ({ title: t.title, artist: t.artist })),
        }),
      });

      const text = await res.text();
      console.log("export status", res.status, "body:", text);

      let data = null;
      try { data = JSON.parse(text); } catch { }

      if (!res.ok) {
        setError(data?.error || text || "Export failed");
        return;
      }


      alert(`Exported! Added ${data.added} tracks`);
      window.open(data.playlistUrl, "_blank");
    } catch (e) {
      setError(e?.message || "Export failed");
    }
  }




  function randomString(length = 64) {
    const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    return Array.from(crypto.getRandomValues(new Uint8Array(length)))
      .map((x) => possible[x % possible.length])
      .join("");
  }

  async function sha256(plain) {
    const encoder = new TextEncoder();
    const data = encoder.encode(plain);
    const digest = await crypto.subtle.digest("SHA-256", data);
    return new Uint8Array(digest);
  }

  function base64UrlEncode(bytes) {
    return btoa(String.fromCharCode(...bytes))
      .replace(/\+/g, "-")
      .replace(/\//g, "_")
      .replace(/=+$/, "");
  }

  async function spotifyLogin() {
    if (!SPOTIFY_CLIENT_ID) throw new Error("Missing VITE_SPOTIFY_CLIENT_ID");

    const verifier = randomString(64);
    const challenge = base64UrlEncode(await sha256(verifier));

    localStorage.setItem("spotify_verifier", verifier);

    const params = new URLSearchParams({
      response_type: "code",
      client_id: SPOTIFY_CLIENT_ID,
      scope: SPOTIFY_SCOPES,
      redirect_uri: REDIRECT_URI,
      code_challenge_method: "S256",
      code_challenge: challenge,
      show_dialog: "true",
    });

    console.log("REDIRECT_URI", REDIRECT_URI);

    window.location = `https://accounts.spotify.com/authorize?${params.toString()}`;
  }

  async function spotifyExchangeCodeForToken(code) {
    const verifier = localStorage.getItem("spotify_verifier");
    if (!verifier) throw new Error("Missing PKCE verifier (click Connect Spotify again)");

    const body = new URLSearchParams({
      client_id: SPOTIFY_CLIENT_ID,
      grant_type: "authorization_code",
      code,
      redirect_uri: REDIRECT_URI,
      code_verifier: verifier,
    });

    const res = await fetch("https://accounts.spotify.com/api/token", {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body,
    });

    const data = await res.json();
    console.log("granted scope:", data.scope);
    console.log("Spotify token response:", data);
    if (!res.ok) {
      console.log("token error response:", data);
      throw new Error(data?.error_description || data?.error || "Token exchange failed");
    }

    const expiresAt = Date.now() + data.expires_in * 1000 - 30_000;
    localStorage.setItem("spotify_access_token", data.access_token);
    localStorage.setItem("spotify_expires_at", String(expiresAt));

    // Optional: store refresh_token if returned (usually is)
    if (data.refresh_token) localStorage.setItem("spotify_refresh_token", data.refresh_token);
  }


  function getSpotifyAccessToken() {
    const token = localStorage.getItem("spotify_access_token");
    const expiresAt = Number(localStorage.getItem("spotify_expires_at") || 0);
    if (!token || Date.now() > expiresAt) return null;
    return token;
  }



  const API_KEY = "17321b7ef90a2af3fd32b254accf6811";

  const bannedTags = new Set([
    "pop",
    "rock",
    "indie",
    "alternative",
    "electronic",
    "hip hop",
    "rap",
    "female vocalists",
    "american"
  ]);

  async function fetchTopTracks(username, period, limit) {
    const url =
      `https://ws.audioscrobbler.com/2.0/?method=user.gettoptracks` +
      `&user=${encodeURIComponent(username)}` +
      `&api_key=${API_KEY}` +
      `&format=json` +
      `&period=${period}` +
      `&limit=${limit}`;

    const res = await fetch(url);
    const data = await res.json();

    if (!data?.toptracks?.track) {
      throw new Error(data?.message || "Failed to fetch top tracks");
    }

    const track = data.toptracks.track;
    return Array.isArray(track) ? track : [track];
  }

  // Returns a merged list with a single score per (artist, track)
  async function fetchTasteProfile(username) {
    const batches = [
      { period: "1month", limit: 50, weight: 1.0 },
      { period: "6month", limit: 25, weight: 0.6 },
      { period: "12month", limit: 25, weight: 0.4 },
    ];

    const results = await Promise.all(
      batches.map(async (b) => {
        const tracks = await fetchTopTracks(username, b.period, b.limit);
        return { ...b, tracks };
      })
    );

    const map = new Map();

    for (const batch of results) {
      batch.tracks.forEach((t, idx) => {
        const artist = t.artist?.name || t.artist;
        const title = t.name;

        if (!artist || !title) return;

        const key = `${artist}|||${title}`.toLowerCase();

        const rankScore = (batch.limit - idx) / batch.limit; // 1.0 -> ~0
        const score = rankScore * batch.weight;

        const prev = map.get(key) || {
          artist,
          title,
          score: 0,
          sources: [],
        };
        prev.score += score;
        prev.sources.push(batch.period);
        map.set(key, prev);
      });
    }

    return Array.from(map.values()).sort((a, b) => b.score - a.score);
  }

  // --- Artist splitting for collabs (feat/ft/&/x/with/etc.) ---
  function splitArtists(artistStr) {
    if (!artistStr) return [];
    return artistStr
      .replace(/\s*\(.*?\)\s*/g, " ") // remove parentheticals
      .split(/feat\.|ft\.|featuring|&|,| x | with /i)
      .map((s) => s.trim())
      .filter(Boolean)
      .map((s) => s.toLowerCase());
  }

  function trackKey(artist, title) {
    return `${artist}|||${title}`.toLowerCase();
  }

  // --- Last.fm artist tags with cache (SUPER IMPORTANT) ---
  const artistTagCacheRef = useRef(new Map());

  async function fetchArtistTags(artistName) {
    const key = (artistName || "").toLowerCase();
    if (!key) return [];
    const cache = artistTagCacheRef.current;

    if (cache.has(key)) return cache.get(key);

    const url =
      `https://ws.audioscrobbler.com/2.0/?method=artist.gettoptags` +
      `&artist=${encodeURIComponent(artistName)}` +
      `&api_key=${API_KEY}` +
      `&format=json`;

    const res = await fetch(url);
    const data = await res.json();

    const tags = (data?.toptags?.tag || [])
      .slice(0, 10)
      .map((t) => (t?.name || "").toLowerCase())
      .filter((tag) => tag && !bannedTags.has(tag));

    cache.set(key, tags);
    return tags;
  }

  // Build overlap tags from top K artists per user
  async function buildOverlapTags(profileA, profileB, topKArtists = 25) {
    const topArtistsA = uniqueTopArtists(profileA).slice(0, topKArtists);
    const topArtistsB = uniqueTopArtists(profileB).slice(0, topKArtists);

    const [tagsA, tagsB] = await Promise.all([
      fetchTagsForArtists(topArtistsA),
      fetchTagsForArtists(topArtistsB),
    ]);

    // Reduce to a set of "important tags" per user
    const topTagsA = topTagsFromFrequency(tagsA, 30); // take top 30 tags
    const topTagsB = topTagsFromFrequency(tagsB, 30);

    const overlap = new Set();
    topTagsA.forEach((t) => {
      if (topTagsB.has(t)) overlap.add(t);
    });

    return {
      overlapTags: overlap,
      topTagsA,
      topTagsB,
      topArtistsA,
      topArtistsB,
    };
  }

  function uniqueTopArtists(profile) {
    const seen = new Set();
    const out = [];
    for (const t of profile) {
      const a = (t.artist || "").toLowerCase();
      if (!a || seen.has(a)) continue;
      seen.add(a);
      out.push(t.artist);
    }
    return out;
  }

  async function fetchTagsForArtists(artists) {
    // parallel fetch; cache prevents duplicates
    const tagLists = await Promise.all(artists.map((a) => fetchArtistTags(a)));
    // build frequency map
    const freq = new Map();
    tagLists.forEach((tags) => {
      tags.forEach((tag) => freq.set(tag, (freq.get(tag) || 0) + 1));
    });
    return freq;
  }

  function topTagsFromFrequency(freqMap, n) {
    const arr = Array.from(freqMap.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, n)
      .map(([tag]) => tag);
    return new Set(arr);
  }

  function countOverlap(tags, overlapSet) {
    let c = 0;
    for (const t of tags) if (overlapSet.has(t)) c++;
    return c;
  }

  function shuffleArray(arr) {
    const a = [...arr];
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }


  // Your algorithm: compatible filter + preselect + fill + relax
  async function generateBlend(profileA, profileB, options = {}) {
    const size = options.size ?? 30;
    const nMin = options.nMin ?? 8; // guarantee per-user representation
    const maxPerArtist = options.maxPerArtist ?? 2;

    // Sets for shared detection
    const keysA = new Set(profileA.map((t) => trackKey(t.artist, t.title)));
    const keysB = new Set(profileB.map((t) => trackKey(t.artist, t.title)));

    // Build artist-token sets (split collabs)
    const artistTokensA = new Set();
    const artistTokensB = new Set();

    profileA.forEach((t) => splitArtists(t.artist).forEach((a) => artistTokensA.add(a)));
    profileB.forEach((t) => splitArtists(t.artist).forEach((a) => artistTokensB.add(a)));

    // Shared artist tokens
    const sharedArtistTokens = new Set();
    artistTokensA.forEach((a) => {
      if (artistTokensB.has(a)) sharedArtistTokens.add(a);
    });

    // Build overlap tags using top artists
    const overlapInfo = await buildOverlapTags(profileA, profileB, 25);
    const overlapTags = overlapInfo.overlapTags;

    // Pre-fetch tags for artists we might touch (top 60 tracks per user is enough) NO ITS NOT BITCH
    const candidateA = profileA;
    const candidateB = profileB;

    const uniqueArtists = new Set();
    [...candidateA, ...candidateB].forEach((t) => uniqueArtists.add((t.artist || "").toLowerCase()));

    // Fetch tags for these artists (cached)
    await Promise.all(Array.from(uniqueArtists).map((aLower) => fetchArtistTags(aLower)));

    const relaxLevels = [5, 4, 3, 2, 1, 0]; // >=2 overlap tags, then >=1, then anything
    let final = [];

    for (const minOverlapTagCount of relaxLevels) {
      const poolA = [];
      const poolB = [];
      const sharedPool = [];

      const compatible = (t) => {
        const k = trackKey(t.artist, t.title);

        const isSharedTrack = keysA.has(k) && keysB.has(k);
        if (isSharedTrack) return { ok: true, reason: "shared_track" };

        const tokens = splitArtists(t.artist);
        const hasSharedArtist = tokens.some((tok) => sharedArtistTokens.has(tok));
        if (hasSharedArtist) return { ok: true, reason: "shared_artist" };

        const tags = artistTagCacheRef.current.get((t.artist || "").toLowerCase()) || [];
        const overlapCount = countOverlap(tags, overlapTags);
        if (overlapCount >= minOverlapTagCount) {
          return { ok: true, reason: `tags_${minOverlapTagCount}+` };
        }

        return { ok: false, reason: "none" };
      };

      // Build pools
      for (const t of candidateA) {
        const c = compatible(t);
        if (!c.ok) continue;
        const item = { ...t, owner: "A", compatReason: c.reason };
        poolA.push(item);
        if (c.reason === "shared_track" || c.reason === "shared_artist") sharedPool.push(item);
      }

      for (const t of candidateB) {
        const c = compatible(t);
        if (!c.ok) continue;
        const item = { ...t, owner: "B", compatReason: c.reason };
        poolB.push(item);
        if (c.reason === "shared_track" || c.reason === "shared_artist") sharedPool.push(item);
      }

      // Sort within pools by score
      const jitter = () => (Math.random() - 0.5) * 0.05;

      poolA.sort((x, y) => (y.score + jitter()) - (x.score + jitter()));
      poolB.sort((x, y) => (y.score + jitter()) - (x.score + jitter()));


      // Shared pool: prefer high score, but de-dupe
      sharedPool.sort((x, y) => y.score - x.score);

      // Pick with constraints
      const picked = [];
      const pickedKeys = new Set();
      const artistCounts = new Map();

      const canPick = (t) => {
        const k = trackKey(t.artist, t.title);
        if (pickedKeys.has(k)) return false;

        const artists = splitArtists(t.artist);
        // count each individual artist token for cap
        for (const a of artists) {
          const count = artistCounts.get(a) || 0;
          if (count >= maxPerArtist) return false;
        }
        return true;
      };

      const doPick = (t) => {
        const k = trackKey(t.artist, t.title);
        pickedKeys.add(k);

        const artists = splitArtists(t.artist);
        for (const a of artists) {
          artistCounts.set(a, (artistCounts.get(a) || 0) + 1);
        }

        picked.push(t);
      };

      // 1) Grab a few from sharedPool first (super cohesive)
      for (const t of sharedPool) {
        if (picked.length >= Math.min(6, size)) break;
        if (canPick(t)) doPick(t);
      }

      // 2) Preselect nMin from each user (representation)
      let aIdx = 0;
      let bIdx = 0;

      while (picked.length < size && (aIdx < poolA.length || bIdx < poolB.length)) {
        if (picked.filter((x) => x.owner === "A").length < nMin) {
          while (aIdx < poolA.length && !canPick(poolA[aIdx])) aIdx++;
          if (aIdx < poolA.length) doPick(poolA[aIdx++]);
        }

        if (picked.length >= size) break;

        if (picked.filter((x) => x.owner === "B").length < nMin) {
          while (bIdx < poolB.length && !canPick(poolB[bIdx])) bIdx++;
          if (bIdx < poolB.length) doPick(poolB[bIdx++]);
        }

        // If both reached nMin, stop preselect loop
        const aCount = picked.filter((x) => x.owner === "A").length;
        const bCount = picked.filter((x) => x.owner === "B").length;
        if (aCount >= nMin && bCount >= nMin) break;
      }

      // 3) Fill remainder by global ranking among compatible tracks
      const global = [...poolA, ...poolB].sort(
        (x, y) => (y.score + jitter()) - (x.score + jitter())
      );

      for (const t of global) {
        if (picked.length >= size) break;
        if (canPick(t)) doPick(t);
      }

      final = picked.slice(0, size);

      // --- Tier-based shuffle (no anchoring, but shared still near top) ---

      // Split into tiers
      const sharedTier = final.filter(
        (t) => t.compatReason === "shared_track" || t.compatReason === "shared_artist"
      );

      const tagTier = final.filter((t) =>
        t.compatReason?.startsWith("tags_")
      );

      const otherTier = final.filter(
        (t) =>
          t.compatReason !== "shared_track" &&
          t.compatReason !== "shared_artist" &&
          !t.compatReason?.startsWith("tags_")
      );

      // Shuffle inside each tier
      const shuffledShared = shuffleArray(sharedTier);
      const shuffledTags = shuffleArray(tagTier);
      const shuffledOther = shuffleArray(otherTier);

      // Rebuild with priority order but no anchoring
      final = [
        ...shuffledShared,
        ...shuffledTags,
        ...shuffledOther,
      ].slice(0, size);


      if (final.length >= size) {
        setDebug({
          minOverlapTagCount,
          overlapTagCount: overlapTags.size,
          topTagsA: Array.from(overlapInfo.topTagsA).slice(0, 10),
          topTagsB: Array.from(overlapInfo.topTagsB).slice(0, 10),
          overlapSample: Array.from(overlapTags).slice(0, 12),
        });
        break;
      }
    }

    return final;
  }

  return (
    <div className="app">
      <header className="header">
        <h1>TunedIn Blend</h1>
      </header>

      <div className="form-card">
        <div className="input-row">
          <input
            placeholder="Last.fm Username 1"
            value={user1}
            onChange={(e) => {
              const v = e.target.value;
              setUser1(v);
              if (v.trim() !== blendUser1) setProfile1(null);
            }}
          />
          <input
            placeholder="Last.fm Username 2"
            value={user2}
            onChange={(e) => {
              const v = e.target.value;
              setUser2(v);
              if (v.trim() !== blendUser2) setProfile2(null);
            }}
          />
        </div>

        <div className="actions">
          <button
            disabled={loading}
            onClick={async () => {
              try {
                setError("");
                setDebug(null);
                setLoading(true);

                const u1 = user1.trim();
                const u2 = user2.trim();
                if (!u1 || !u2) {
                  throw new Error("Enter two Last.fm usernames.");
                }

                const useProfile1 = profile1 && u1 === blendUser1;
                const useProfile2 = profile2 && u2 === blendUser2;
                let p1 = useProfile1 ? profile1 : null;
                let p2 = useProfile2 ? profile2 : null;

                if (!p1 || !p2) {
                  const profiles = await Promise.all([
                    p1 ? Promise.resolve(p1) : fetchTasteProfile(u1),
                    p2 ? Promise.resolve(p2) : fetchTasteProfile(u2),
                  ]);
                  if (!p1) {
                    p1 = profiles[0];
                    setProfile1(p1);
                  }
                  if (!p2) {
                    p2 = profiles[1];
                    setProfile2(p2);
                  }
                }

                const blended = await generateBlend(p1, p2, {
                  size: 30,
                  nMin: 8,
                  maxPerArtist: 2,
                });

                if (!blended.length) {
                  throw new Error("Couldn't generate a blend (try different users).");
                }

                setBlend(blended);
                setBlendUser1(u1);
                setBlendUser2(u2);
                try {
                  localStorage.setItem(
                    BLEND_STORAGE_KEY,
                    JSON.stringify({ blend: blended, user1: u1, user2: u2 })
                  );
                } catch (_) {}
              } catch (e) {
                setError(e?.message || "Something went wrong");
              } finally {
                setLoading(false);
              }
            }}
          >
            {loading
              ? "Generating..."
              : profile1 && profile2
                ? "Regenerate"
                : "Generate Blend"}
          </button>

          {!spotifyConnected ? (
            <button onClick={connectSpotify}>Connect Spotify</button>
          ) : (
            <button
              disabled={blend.length === 0}
              onClick={exportToSpotify}
            >
              Export to Spotify
            </button>
          )}
        </div>

        {error && <p className="error-msg">{error}</p>}
      </div>

      {blend.length > 0 && (
        <section className="blend-section">
          <h2 className="blend-title">Your Blend</h2>
          <ol className="track-list">
            {blend.map((t, idx) => (
              <li key={`${t.artist}-${t.title}-${idx}`} className="track-row">
                <div className="track-info">
                  <p className="track-title">{t.title}</p>
                  <p className="track-artist">{t.artist}</p>
                </div>
                <span
                  className={`track-badge ${t.compatReason === "shared_track" ? "shared" : ""}`}
                >
                  {t.compatReason === "shared_track"
                    ? "Shared"
                    : t.owner === "A"
                      ? blendUser1
                      : blendUser2}
                </span>
              </li>
            ))}
          </ol>
        </section>
      )}

      {debug && (
        <div className="debug-panel">
          <div>
            <strong>Debug:</strong> min overlap tags used = {debug.minOverlapTagCount}, overlap tag count ={" "}
            {debug.overlapTagCount}
          </div>
          <div>
            overlap sample: {debug.overlapSample.join(", ")}
          </div>
        </div>
      )}
    </div>
  );
}

export default App;
